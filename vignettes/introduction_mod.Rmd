---
title: "Introduction to dfms"
author: "Sebastian Krantz"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to dfms}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  cache = TRUE,
  fig.width = 7,
  fig.height = 5,
  comment = "#>"
)

opt <- options(max.print = 70)
```



```{r setup, message=FALSE}
library(dfms)
library(xts)
library(magrittr)
```

This vignette modifies the introduction to dfms vignetted



The data frame `BM14_Models` provides information about the series^[Both about the monthly ones and quarterly series contained in `BM14_Q`. The order of rows in `BM14_Models` matches the column order of series in `merge(BM14_M, BM14_Q)`.], and the various models estimated by BM14. 

```{r}
head(BM14_Models, 3)

# Add annual data column to model metadata
BM14_Models_M <- BM14_Models %>% 
  dplyr::bind_rows(dplyr::tibble(series = "sp500_mod",
                   label = "SP500_mod", code = "", freq = "M" ,
                   log_trans = TRUE, small = TRUE, med = FALSE, large = FALSE))
# Using only monthly data
BM14_Models_M <- subset(BM14_Models, freq == "M")
```

Prior to estimation, all data is differenced by BM14, and some series are log, differenced, as indicated by the `log_trans` column in `BM14_Models`. In general, *dfms* uses a stationary Kalman Filter with time-invariant system matrices, and therefore expects data to be stationary. Data is also scaled and centered^[Data must be scaled and centered because the Kalman Filter has no intercept term.] in the main `DFM()` function, thus this does not need to be done by the user. 

```{r}

# log-transforming and first-differencing the data
BM14_M[, BM14_Models_M$log_trans] %<>% log()
BM14_M_diff = diff(BM14_M)

## Add a column of annual data
BM14_mod <- BM14_M_diff %>% 
  fortify.zoo %>% dplyr::as_tibble() %>% 
  dplyr::mutate(sp500_mod = 5* sp500+ 10, 
         sp500_mod = dplyr::if_else(mod(lubridate::month(
           lubridate::ymd(Index)), 12) == 0, sp500_mod, NA),
         #set the last data point to NA to be used as nowcast value
         sp500_mod = dplyr::if_else(as.character(Index) == "2008-12-31",
                                    NA, sp500_mod))
  
#convert to xts
BM14_mod <- xts(BM14_mod[,-1], order.by = as.POSIXct(BM14_mod[[1]]))


```

Fit the model as per the introduction vignette 

```{r}
# Estimating the model with 4 factors and 3 lags using BM14's EM algorithm
model1 = DFM(BM14_mod, r = 4, p = 3)
print(model1)
plot(model1)
```

Explore the model

```{r}
res <- resid(model1, orig.format = TRUE)
fit <- fitted(model1, orig.format = TRUE)
#compare the residuals for the annual modified variable and the oriiginal variable
check_resid <- which(abs(res$sp500_mod) > abs(res$sp500) )

## Use the observation equation to generate the nowcasted observed values. Use F_pca, but could use F_qml or F_2s
C <- as.matrix(model1$C)
F_pca <- t(as.matrix(model1$F_pca))

nowcast <- C %*% F_pca
plot(t(nowcast)[,93], t(nowcast)[,86], xlab = "estimated sp500_mod", ylab = "estimated sp500")

```




## Estimation with Mixed Frequency

As per the suggestion in the vignette, duplicate the columns of annual data to increase the weight. More than 5 replications of column sp500_mod leads to a singular matrix error. So here use 5 reps and repeat above analysis

```{r}
BM14_mod_mix_f <- cbind(BM14_mod, BM14_mod$sp500_mod,
                        BM14_mod$sp500_mod, BM14_mod$sp500_mod,
                        BM14_mod$sp500_mod)

model2 = DFM(BM14_mod_mix_f, r = 4, p = 3, max.iter = 10000)


res <- resid(model2, orig.format = TRUE)
fit <- fitted(model2, orig.format = TRUE)
#compare the residuals for the annual modified variable and the oriiginal variable
check_resid <- which(abs(res$sp500_mod) > abs(res$sp500) )

## Use the observation equation to generate the nowcasted observed values. Use F_pca, but could use F_qml or F_2s
C <- as.matrix(model1$C)
F_pca <- t(as.matrix(model1$F_pca))

nowcast <- C %*% F_pca
plot(t(nowcast)[,93], t(nowcast)[,86], xlab = "estimated sp500_mod", ylab = "estimated sp500")

```
The negative correlation between the sp500 and sp500_mod is not altered by replicating the columns to increase the weight.

## References

Doz, C., Giannone, D., & Reichlin, L. (2011). A two-step estimator for large approximate dynamic factor models based on Kalman filtering. *Journal of Econometrics, 164*(1), 188-205.

Doz, C., Giannone, D., & Reichlin, L. (2012). A quasi-maximum likelihood approach for large, approximate dynamic factor models. *Review of Economics and Statistics, 94*(4), 1014-1024.

Banbura, M., & Modugno, M. (2014). Maximum likelihood estimation of factor models on datasets with arbitrary pattern of missing data. *Journal of Applied Econometrics, 29*(1), 133-160.

Mariano, R. S., & Murasawa, Y. (2003). A new coincident index of business cycles based on monthly and quarterly series. *Journal of Applied Econometrics, 18*(4), 427-443.

Bai, J., Ng, S. (2002). Determining the Number of Factors in Approximate Factor Models. *Econometrica, 70*(1), 191-221. 

Onatski, A. (2010). Determining the number of factors from empirical distribution of eigenvalues. *The Review of Economics and Statistics, 92*(4), 1004-1016.

Stock, J. H., & Watson, M. W. (2016). Dynamic Factor Models, Factor-Augmented Vector Autoregressions, and Structural Vector Autoregressions in Macroeconomics. *Handbook of Macroeconomics, 2*, 415â€“525. 

```{r, include=FALSE}
options(opt)
```

